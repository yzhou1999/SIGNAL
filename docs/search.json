[{"path":"/articles/Knowledge_transfer.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Knowledge transfer from reference to query using SIGNAL","text":"SIGNAL allows knowledge transfer form reference data query data, containing two tasks: reference-based annotation reference-based integration. latter integrates data based labels predicted former. vignette, use two human cortex scRNA-seq datasets (human MTG human cortex datasets) demonstrate perform two tasks SIGNAL. use human MTG reference human cortex query. removed cell type reference test label annotation integration scenarios novel cell types query data.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(randomcoloR) library(cowplot) set.seed(2024)"},{"path":"/articles/Knowledge_transfer.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Knowledge transfer from reference to query using SIGNAL","text":"identify HVGs reference read expression matrix reference query normalized subset HVGs. Among , 2000 genes query overlapped identified HVGs. represent missing gene query 0.","code":"ref_X = readRDS(paste0(\"/home/server/zy/group_scripts/datasets_preparation/Human_MTG/X.rds\")) ref_meta = readRDS(paste0(\"/home/server/zy/group_scripts/datasets_preparation/Human_MTG/meta.rds\"))[, c(\"Batch\", \"SubClass\")] ref_meta$Dataset = \"reference\" ref_meta = ref_meta[which(!ref_meta$SubClass %in% c(\"Sst Chodl\", \"L5 ET\", \"Endothelial\", \"L4 IT\", \"Oligodendrocyte\", \"L2/3 IT\")), ] ref_X = ref_X[, rownames(ref_meta)]  query_X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Human_cortex/new_X.rds\") query_meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Human_cortex/meta.rds\")[, c(\"Batch\", \"SubClass\")] query_meta$Dataset = \"query\" str(ref_X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:47935347] 17 42 44 59 82 87 91 100 104 106 ... ##   ..@ p       : int [1:85652] 0 540 1177 1961 2453 2940 3427 3969 4793 5192 ... ##   ..@ Dim     : int [1:2] 4000 85651 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:4000] \"MIR1302-2HG\" \"LINC02593\" \"SAMD11\" \"TMEM88B\" ... ##   .. ..$ : chr [1:85651] \"AAACCCAAGTGATCGG-L8TX_191029_01_A07-1156636564\" \"AAACCCACAGGACTTT-L8TX_191029_01_A07-1156636564\" \"AAACCCAGTCTCGGAC-L8TX_191029_01_A07-1156636564\" \"AAACCCAGTTCTCGCT-L8TX_191029_01_A07-1156636564\" ... ##   ..@ x       : num [1:47935347] 3.445 0.446 0.753 1.89 0.446 ... ##   ..@ factors : list() str(ref_meta) ## 'data.frame':    85651 obs. of  3 variables: ##  $ Batch   : chr  \"Donor1\" \"Donor1\" \"Donor1\" \"Donor1\" ... ##  $ SubClass: chr  \"Sst\" \"L5 IT\" \"L5 IT\" \"L5 IT\" ... ##  $ Dataset : chr  \"reference\" \"reference\" \"reference\" \"reference\" ... str(query_X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:173988543] 11 46 48 61 63 69 70 71 72 77 ... ##   ..@ p       : int [1:379331] 0 354 792 1312 1726 2177 2699 3095 3549 4008 ... ##   ..@ Dim     : int [1:2] 2269 379330 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:2269] \"SAMD11\" \"TMEM88B\" \"VWA1\" \"HES5\" ... ##   .. ..$ : chr [1:379330] \"AAACCCAAGAGAGGTA-L8TX_190416_01_C06-871132075\" \"AAACGAAGTTGACGGA-L8TX_190416_01_C06-871132075\" \"AAACGAATCTCAAAGC-L8TX_190416_01_C06-871132075\" \"AAACGCTGTACTCGCG-L8TX_190416_01_C06-871132075\" ... ##   ..@ x       : num [1:173988543] 1.83 0.84 0.84 1.29 0.84 ... ##   ..@ factors : list() str(query_meta) ## 'data.frame':    379330 obs. of  3 variables: ##  $ Batch   : chr  \"H17.26.003\" \"H17.26.003\" \"H17.26.003\" \"H17.26.003\" ... ##  $ SubClass: chr  \"L2/3 IT\" \"L2/3 IT\" \"L2/3 IT\" \"L2/3 IT\" ... ##  $ Dataset : chr  \"query\" \"query\" \"query\" \"query\" ... zero_m = sparseMatrix(i = integer(0), j = integer(0), dims = c(nrow(ref_X) - nrow(query_X), ncol(query_X))) rownames(zero_m) = setdiff(rownames(ref_X), rownames(query_X)) colnames(zero_m) = colnames(query_X) query_X = rbind(query_X, zero_m)[rownames(ref_X), ]"},{"path":"/articles/Knowledge_transfer.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"Visualization of raw data","title":"Knowledge transfer from reference to query using SIGNAL","text":"","code":"Colors = distinctColorPalette(24) X = cbind(ref_X, query_X) meta = rbind.data.frame(ref_meta, query_meta) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Dataset\", palette = c(\"#196534\", \"#9ED089\"), legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"SubClass\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, align = 'h', axis = \"b\")"},{"path":"/articles/Knowledge_transfer.html","id":"label-prediction-and-reference-based-integration","dir":"Articles","previous_headings":"","what":"Label prediction and reference-based integration","title":"Knowledge transfer from reference to query using SIGNAL","text":"check whether SIGNAL can distinguish cell types removed reference.","code":"predicted_labels = Run.LabelTransfer.Single(ref_X, ref_meta$SubClass, query_X) str(predicted_labels) ## 'data.frame':    379330 obs. of  2 variables: ##  $ Prediction: chr  \"L6 IT\" \"L6 IT\" \"L5 IT\" \"L6 IT\" ... ##  $ Confidence: num  0.517 0.595 0.571 0.497 0.581 ... meta$Prediction = c(ref_meta$SubClass, predicted_labels$Prediction) meta$Confidence = c(rep(NA, nrow(ref_meta)), predicted_labels$Confidence) signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Prediction\", \"Dataset\"), b_factor = \"Batch\",                        excluded.cells = which(meta$Dataset== 'query')[which(predicted_labels$Confidence < 0.8)]) ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Dataset\", palette = c(\"#196534\", \"#9ED089\"), legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"SubClass\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap[which(meta$Dataset == \"query\"),], x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Confidence\", legend = \"right\") + gradient_color(c(\"red\",  \"white\", \"blue\")) plot_grid(q1, q2, q3, align = 'h', axis = \"b\", nrow = 1) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1       randomcoloR_1.1.0.1 ggpubr_0.6.0        ## [4] ggplot2_3.4.4       uwot_0.2.2          irlba_2.3.5.1       ## [7] Matrix_1.5-4.1      SIGNAL_1.0.0        ##  ## loaded via a namespace (and not attached): ##  [1] matrixStats_1.0.0        fs_1.6.4                 flock_0.7                ##  [4] RcppAnnoy_0.0.22         doParallel_1.0.17        tools_4.2.3              ##  [7] backports_1.4.1          bslib_0.7.0              utf8_1.2.4               ## [10] R6_2.5.1                 BiocGenerics_0.44.0      colorspace_2.1-0         ## [13] withr_3.0.0              tidyselect_1.2.1         bit_4.0.5                ## [16] curl_5.2.1               compiler_4.2.3           bigparallelr_0.3.2       ## [19] textshaping_0.3.7        cli_3.6.2                BiocNeighbors_1.16.0     ## [22] desc_1.4.3               labeling_0.4.3           sass_0.4.9               ## [25] scales_1.3.0             pkgdown_2.0.7            systemfonts_1.0.6        ## [28] stringr_1.5.1            digest_0.6.35            rmarkdown_2.26           ## [31] pkgconfig_2.0.3          htmltools_0.5.8.1        sparseMatrixStats_1.10.0 ## [34] MatrixGenerics_1.10.0    fastmap_1.1.1            highr_0.10               ## [37] rlang_1.1.3              rstudioapi_0.15.0        jquerylib_0.1.4          ## [40] generics_0.1.3           farver_2.1.1             jsonlite_1.8.8           ## [43] mclust_6.0.0             BiocParallel_1.32.6      dplyr_1.1.4              ## [46] car_3.1-2                magrittr_2.0.3           Rcpp_1.0.12              ## [49] munsell_0.5.1            S4Vectors_0.36.2         fansi_1.0.6              ## [52] abind_1.4-5              lifecycle_1.0.4          stringi_1.8.3            ## [55] yaml_2.3.8               carData_3.0-5            Rtsne_0.17               ## [58] grid_4.2.3               parallel_4.2.3           lattice_0.21-8           ## [61] knitr_1.46               ps_1.7.6                 pillar_1.9.0             ## [64] ggsignif_0.6.4           bigstatsr_1.5.12         codetools_0.2-19         ## [67] stats4_4.2.3             bigassertr_0.1.6         glue_1.7.0               ## [70] evaluate_0.23            V8_4.4.2                 vctrs_0.6.5              ## [73] foreach_1.5.2            gtable_0.3.5             purrr_1.0.2              ## [76] tidyr_1.3.1              cachem_1.0.8             xfun_0.43                ## [79] broom_1.0.5              RcppEigen_0.3.4.0.0      ff_4.0.12                ## [82] RSpectra_0.16-1          rstatix_0.7.2            ragg_1.2.7               ## [85] tibble_3.2.1             iterators_1.0.14         memoise_2.0.1            ## [88] cluster_2.1.4            rmio_0.4.0"},{"path":"/articles/Multiscale_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"Multi-scale analysis by multiple group variables","text":"can use SIGNAL perform multi-scale analysis single-cell data identify cell subtypes specific tissues, conditions, developmental stages.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(randomcoloR) library(cowplot) set.seed(2024)"},{"path":"/articles/Multiscale_analysis.html","id":"application-on-the-developing-human-immune-cell-atlas","dir":"Articles","previous_headings":"","what":"2. Application on the developing human immune cell atlas","title":"Multi-scale analysis by multiple group variables","text":"vignette, first demonstrate recently published developing human immune cell atlas SIGNAL can used integrate way preserves differences tissues developmental stages.","code":""},{"path":"/articles/Multiscale_analysis.html","id":"load-data-matrix-and-metadata","dir":"Articles","previous_headings":"","what":"2.1 Load data matrix and metadata","title":"Multi-scale analysis by multiple group variables","text":"perform data integration normalized scRNA-seq gene expression matrix. HVGs provided authors used.","code":"X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/X.rds\") meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/meta.rds\") str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:201165610] 1 9 10 23 37 44 49 50 52 54 ... ##   ..@ p       : int [1:884584] 0 491 904 1321 1864 2260 2709 3148 3657 4110 ... ##   ..@ Dim     : int [1:2] 3765 884583 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:3765] \"TNMD\" \"FGR\" \"CFH\" \"CFTR\" ... ##   .. ..$ : chr [1:884583] \"FCAImmP7579224-ATTACTCTCGATGAGG\" \"FCAImmP7579224-CAGCCGAGTACATCCA\" \"FCAImmP7579224-TGCTACCTCATGTAGC\" \"FCAImmP7579224-ACGGCCACAAGCTGAG\" ... ##   ..@ x       : num [1:201165610] 2.211 0.965 0.965 2.015 1.447 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    884583 obs. of  4 variables: ##  $ Batch   : chr  \"F45\" \"F45\" \"F45\" \"F45\" ... ##  $ Stage   : Factor w/ 11 levels \"4 PCW\",\"7 PCW\",..: 7 7 7 7 7 7 7 7 7 7 ... ##  $ Tissue  : Factor w/ 9 levels \"Bone Marrow\",..: 6 6 6 6 6 6 6 6 6 6 ... ##  $ CellType: Factor w/ 13 levels \"B cells\",\"Endothelium\",..: 8 4 8 8 1 8 8 8 8 8 ..."},{"path":"/articles/Multiscale_analysis.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"2.2 Visualization of raw data","title":"Multi-scale analysis by multiple group variables","text":"","code":"Colors = distinctColorPalette(13) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p3 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, p3, align = 'h', axis = \"b\", nrow = 1)"},{"path":"/articles/Multiscale_analysis.html","id":"signal-integration-using-tissue-and-stage-as-group-variables-in-a-two-group-setting","dir":"Articles","previous_headings":"","what":"2.3 SIGNAL integration using ‘tissue’ and ‘stage’ as group variables in a two-group setting","title":"Multi-scale analysis by multiple group variables","text":"","code":"signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Tissue\", \"Stage\"), b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, q3, align = 'h', axis = \"b\", nrow = 1)"},{"path":"/articles/Multiscale_analysis.html","id":"application-on-the-mouse-islet-atlas","dir":"Articles","previous_headings":"","what":"3. Application on the mouse islet atlas","title":"Multi-scale analysis by multiple group variables","text":"next apply SIGNAL integrate recently published mouse islet atlas using three-group setting.","code":""},{"path":"/articles/Multiscale_analysis.html","id":"load-data-matrix-and-metadata-1","dir":"Articles","previous_headings":"","what":"3.1 Load data matrix and metadata","title":"Multi-scale analysis by multiple group variables","text":"perform data integration normalized scRNA-seq gene expression matrix. HVGs provided authors used.","code":"X = readRDS('/home/server/zy/group_scripts/datasets_preparation/Mouse_islet_atlas/X.rds') meta = readRDS('/home/server/zy/group_scripts/datasets_preparation/Mouse_islet_atlas/Meta.rds') str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:95717760] 8 11 13 14 15 17 21 22 24 25 ... ##   ..@ p       : int [1:264019] 0 506 924 1379 1666 1924 2017 2176 2526 2855 ... ##   ..@ Dim     : int [1:2] 4000 264018 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:4000] \"Glycam1\" \"Ighg2b\" \"Ighm\" \"Hbb-bs\" ... ##   .. ..$ : chr [1:264018] \"CAAGATCGTCCAGTTA-1-SRR7610301-NOD_elimination\" \"GATGAAAGTTGTCGCG-1-SRR7610298-NOD_elimination\" \"AGTCTTTAGGAGCGTT-1-SRR7610301-NOD_elimination\" \"CTTCCTTGTACCCAGC-1-MUC13640-VSG\" ... ##   ..@ x       : num [1:95717760] 1.46 2.17 1.46 1.17 1.17 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    264018 obs. of  5 variables: ##  $ Batch   : chr  \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610301\" \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610298\" \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610301\" \"mouse_pancreatic_islet_atlas_Hrovatin__VSG__MUC13640\" ... ##  $ CellType: Factor w/ 11 levels \"α\",\"β\",\"δ\",\"PP\",..: 6 4 8 9 11 4 3 7 4 9 ... ##  $ Stage   : Factor w/ 9 levels \"E\",\"2w\",\"5w\",..: 6 6 6 7 4 8 7 7 8 7 ... ##  $ Disease : Factor w/ 4 levels \"normal\",\"type 1 diabetes mellitus\",..: 2 2 2 3 1 3 3 3 3 3 ... ##  $ Sex     : chr  \"female\" \"female\" \"female\" \"male\" ..."},{"path":"/articles/Multiscale_analysis.html","id":"visualization-of-raw-data-1","dir":"Articles","previous_headings":"","what":"3.2 Visualization of raw data","title":"Multi-scale analysis by multiple group variables","text":"","code":"Colors = distinctColorPalette(11) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Sex\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p3 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Disease\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p4 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, p3, p4, align = 'h', axis = \"b\", nrow = 2)"},{"path":"/articles/Multiscale_analysis.html","id":"signal-integration-using-sex-disease-and-stage-as-group-variables-in-a-two-group-setting","dir":"Articles","previous_headings":"","what":"3.3 SIGNAL integration using ‘sex’, ‘disease’, and ‘stage’ as group variables in a two-group setting","title":"Multi-scale analysis by multiple group variables","text":"","code":"signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Sex\", \"Disease\", \"Stage\"), b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Sex\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Disease\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q4 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, q3, q4, align = 'h', axis = \"b\", nrow = 2) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1       randomcoloR_1.1.0.1 ggpubr_0.6.0        ## [4] ggplot2_3.4.4       uwot_0.2.2          irlba_2.3.5.1       ## [7] Matrix_1.5-4.1      SIGNAL_1.0.0        ##  ## loaded via a namespace (and not attached): ##  [1] matrixStats_1.0.0        fs_1.6.4                 flock_0.7                ##  [4] RcppAnnoy_0.0.22         doParallel_1.0.17        tools_4.2.3              ##  [7] backports_1.4.1          bslib_0.7.0              utf8_1.2.4               ## [10] R6_2.5.1                 BiocGenerics_0.44.0      colorspace_2.1-0         ## [13] withr_3.0.0              tidyselect_1.2.1         bit_4.0.5                ## [16] curl_5.2.1               compiler_4.2.3           bigparallelr_0.3.2       ## [19] textshaping_0.3.7        cli_3.6.2                BiocNeighbors_1.16.0     ## [22] desc_1.4.3               labeling_0.4.3           sass_0.4.9               ## [25] scales_1.3.0             pkgdown_2.0.7            systemfonts_1.0.6        ## [28] stringr_1.5.1            digest_0.6.35            rmarkdown_2.26           ## [31] pkgconfig_2.0.3          htmltools_0.5.8.1        sparseMatrixStats_1.10.0 ## [34] MatrixGenerics_1.10.0    fastmap_1.1.1            highr_0.10               ## [37] rlang_1.1.3              rstudioapi_0.15.0        jquerylib_0.1.4          ## [40] generics_0.1.3           farver_2.1.1             jsonlite_1.8.8           ## [43] mclust_6.0.0             BiocParallel_1.32.6      dplyr_1.1.4              ## [46] car_3.1-2                magrittr_2.0.3           Rcpp_1.0.12              ## [49] munsell_0.5.1            S4Vectors_0.36.2         fansi_1.0.6              ## [52] abind_1.4-5              lifecycle_1.0.4          stringi_1.8.3            ## [55] yaml_2.3.8               carData_3.0-5            Rtsne_0.17               ## [58] grid_4.2.3               parallel_4.2.3           lattice_0.21-8           ## [61] knitr_1.46               ps_1.7.6                 pillar_1.9.0             ## [64] ggsignif_0.6.4           bigstatsr_1.5.12         codetools_0.2-19         ## [67] stats4_4.2.3             bigassertr_0.1.6         glue_1.7.0               ## [70] evaluate_0.23            V8_4.4.2                 vctrs_0.6.5              ## [73] foreach_1.5.2            gtable_0.3.5             purrr_1.0.2              ## [76] tidyr_1.3.1              cachem_1.0.8             xfun_0.43                ## [79] broom_1.0.5              RcppEigen_0.3.4.0.0      ff_4.0.12                ## [82] RSpectra_0.16-1          rstatix_0.7.2            ragg_1.2.7               ## [85] tibble_3.2.1             iterators_1.0.14         memoise_2.0.1            ## [88] cluster_2.1.4            rmio_0.4.0"},{"path":"/articles/Supervised_integration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Supervised integration using SIGNAL","text":"SIGNAL integration requires least one group variable, ‘cell type,’ ‘developmental stage,’ ‘tissue origin,’ typically provided metadata. Actually, SIGNAL assumes homogeneity within subgroups given group variable. additional group variable entirely, one can consider manually adding ‘source’ variable indicates whether cells come source. However, mentioned , dataset highly heterogeneous, SIGNAL effectively integrate dataset. introduce metric, -batch similarity, quantify homogeneity across batches within dataset. high -batch similarity indicates homogeneity. contrast, -batch similarity low, indicating heterogeneity, SIGNAL integration manually added ‘source’ variable may succeed. Next, show using heterogeneous cell lines dataset.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(cowplot) set.seed(2024)"},{"path":"/articles/Supervised_integration.html","id":"load-data-matrix-and-metadata","dir":"Articles","previous_headings":"","what":"Load data matrix and metadata","title":"Supervised integration using SIGNAL","text":"demonstrate SIGNAL integration commonly used single-cell RNA sequencing (scRNA-seq) dataset cell lines. highly variable genes (HVGs) already selected used perform integration. dataset highly heterogeneous across batches, can see cell type compositions dataset. also compute -batch similarity.","code":"X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Jurkat_293t/X.rds\") meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Jurkat_293t/meta.rds\") table(meta[, c(\"CellType\", \"Batch\")]) ##         Batch ## CellType Batch_1 Batch_2 Batch_3 ##   293t      2885       0    1605 ##   jurkat       0    3258    1783 batch_similarity <- function(data, meta, b_factor) {     scaled_data = SIGNAL:::scale_data(data)     b_ns = unique(meta[, b_factor])     b_means = sapply(b_ns, function(b) matrixStats::rowMedians(as.matrix(scaled_data[, which(meta[, b_factor] == b)] )))     colnames(b_means) = b_ns     b_means = scInt:::cosineNorm(b_means)     all_b_means = rowMeans(b_means)     mean(apply(b_means, 2, function(x) cor(x, all_b_means, method = 'pearson'))) } print(round(batch_similarity(X, meta, 'Batch'), 2) ) ## [1] 0.51"},{"path":"/articles/Supervised_integration.html","id":"signal-integration-with-a-manually-added-source-variable","dir":"Articles","previous_headings":"","what":"SIGNAL integration with a manually added ‘source’ variable","title":"Supervised integration using SIGNAL","text":"manually add ‘source’ variable cells data. SIGNAL separate two cell types.  simulate batch labels construct homogeneous dataset integrate using SIGNAL using ‘source’ group variable.","code":"meta$Source = '0' signal_emb = Run.gcPCA(X, meta, g_factor = \"Source\", b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) p1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Batch\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, align = 'h', axis = \"b\") meta$NewLabel = as.character(meta$Batch) meta$NewLabel[which(meta$NewLabel %in% c('Batch_1', 'Batch_2'))] = 'Simulated Batch_1' meta$NewLabel[which(meta$NewLabel == 'Batch_3')] = 'Simulated Batch_2' signal_emb = Run.gcPCA(X, meta, g_factor = \"Source\", b_factor = \"NewLabel\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Batch\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, align = 'h', axis = \"b\")"},{"path":"/articles/Supervised_integration.html","id":"signal-integration-for-highly-homogeneous-datasets-without-prior-information","dir":"Articles","previous_headings":"","what":"SIGNAL integration for highly homogeneous datasets without prior information","title":"Supervised integration using SIGNAL","text":"integrate heterogeneous single-cell data without prior information, recommend using additional unsupervised integration methods previously proposed scInt clustering techniques like k-means create coarse cell labels. SIGNAL can operated supervised integration method.","code":"sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1  ggpubr_0.6.0   ggplot2_3.4.4  uwot_0.2.2     irlba_2.3.5.1  ## [6] Matrix_1.5-4.1 SIGNAL_1.0.0   ##  ## loaded via a namespace (and not attached): ##   [1] backports_1.4.1          systemfonts_1.0.6        RcppEigen_0.3.4.0.0      ##   [4] plyr_1.8.9               igraph_1.3.1             lazyeval_0.2.2           ##   [7] sp_2.1-3                 splines_4.2.3            BiocParallel_1.32.6      ##  [10] listenv_0.9.1            scattermore_1.2          digest_0.6.35            ##  [13] foreach_1.5.2            htmltools_0.5.8.1        fansi_1.0.6              ##  [16] magrittr_2.0.3           memoise_2.0.1            tensor_1.5               ##  [19] cluster_2.1.4            doParallel_1.0.17        ROCR_1.0-11              ##  [22] bigassertr_0.1.6         bigstatsr_1.5.12         globals_0.16.3           ##  [25] matrixStats_1.0.0        spatstat.sparse_3.0-2    pkgdown_2.0.7            ##  [28] colorspace_2.1-0         ggrepel_0.9.5            textshaping_0.3.7        ##  [31] xfun_0.43                dplyr_1.1.4              jsonlite_1.8.8           ##  [34] spatstat.data_3.0-1      progressr_0.13.0         survival_3.5-5           ##  [37] flock_0.7                zoo_1.8-12               iterators_1.0.14         ##  [40] glue_1.7.0               polyclip_1.10-4          gtable_0.3.5             ##  [43] leiden_0.4.3             car_3.1-2                future.apply_1.11.0      ##  [46] BiocGenerics_0.44.0      rfunctions_0.1           abind_1.4-5              ##  [49] scales_1.3.0             bigparallelr_0.3.2       spatstat.random_3.1-5    ##  [52] rstatix_0.7.2            miniUI_0.1.1.1           Rcpp_1.0.12              ##  [55] viridisLite_0.4.2        xtable_1.8-4             reticulate_1.26          ##  [58] bit_4.0.5                mclust_6.0.0             stats4_4.2.3             ##  [61] htmlwidgets_1.6.4        httr_1.4.7               RColorBrewer_1.1-3       ##  [64] Seurat_4.3.0.1           ff_4.0.12                ica_1.0-3                ##  [67] farver_2.1.1             pkgconfig_2.0.3          deldir_2.0-4             ##  [70] sass_0.4.9               utf8_1.2.4               labeling_0.4.3           ##  [73] tidyselect_1.2.1         rlang_1.1.3              reshape2_1.4.4           ##  [76] later_1.3.2              munsell_0.5.1            tools_4.2.3              ##  [79] cachem_1.0.8             cli_3.6.2                generics_0.1.3           ##  [82] broom_1.0.5              ggridges_0.5.4           evaluate_0.23            ##  [85] stringr_1.5.1            fastmap_1.1.1            goftest_1.2-3            ##  [88] yaml_2.3.8               ragg_1.2.7               knitr_1.46               ##  [91] fs_1.6.4                 fitdistrplus_1.1-11      purrr_1.0.2              ##  [94] RANN_2.6.1               nlme_3.1-162             pbapply_1.7-2            ##  [97] future_1.33.1            sparseMatrixStats_1.10.0 mime_0.12                ## [100] compiler_4.2.3           rstudioapi_0.15.0        scInt_1.0                ## [103] plotly_4.10.4            png_0.1-8                ggsignif_0.6.4           ## [106] spatstat.utils_3.1-0     tibble_3.2.1             bslib_0.7.0              ## [109] stringi_1.8.3            highr_0.10               ps_1.7.6                 ## [112] desc_1.4.3               RSpectra_0.16-1          lattice_0.21-8           ## [115] ggsci_3.0.0              vctrs_0.6.5              pillar_1.9.0             ## [118] lifecycle_1.0.4          spatstat.geom_3.2-1      lmtest_0.9-40            ## [121] jquerylib_0.1.4          RcppAnnoy_0.0.22         BiocNeighbors_1.16.0     ## [124] data.table_1.15.4        httpuv_1.6.15            patchwork_1.1.2          ## [127] R6_2.5.1                 promises_1.3.0           KernSmooth_2.23-21       ## [130] gridExtra_2.3            parallelly_1.37.1        codetools_0.2-19         ## [133] MASS_7.3-60              withr_3.0.0              SeuratObject_4.1.3       ## [136] sctransform_0.3.5        S4Vectors_0.36.2         parallel_4.2.3           ## [139] grid_4.2.3               tidyr_1.3.1              rmio_0.4.0               ## [142] rmarkdown_2.26           MatrixGenerics_1.10.0    carData_3.0-5            ## [145] Rtsne_0.17               spatstat.explore_3.2-1   Biobase_2.58.0           ## [148] shiny_1.8.1.1"},{"path":"/articles/Unsupervised_integration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"SIGNAL integration for unlabeled datasets","text":"can use SIGNAL perform multi-scale analysis single-cell data identify cell subtypes specific tissues, conditions, developmental stages.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(randomcoloR) library(cowplot) set.seed(2024)"},{"path":"/articles/Unsupervised_integration.html","id":"application-on-the-developing-human-immune-cell-atlas","dir":"Articles","previous_headings":"","what":"2. Application on the developing human immune cell atlas","title":"SIGNAL integration for unlabeled datasets","text":"vignette, first demonstrate recently published developing human immune cell atlas SIGNAL can used integrate way preserves differences tissues developmental stages.","code":""},{"path":"/articles/Unsupervised_integration.html","id":"load-data-matrix-and-metadata","dir":"Articles","previous_headings":"","what":"2.1 Load data matrix and metadata","title":"SIGNAL integration for unlabeled datasets","text":"perform data integration normalized scRNA-seq gene expression matrix. HVGs provided authors used.","code":"X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/X.rds\") meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/meta.rds\") str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:201165610] 1 9 10 23 37 44 49 50 52 54 ... ##   ..@ p       : int [1:884584] 0 491 904 1321 1864 2260 2709 3148 3657 4110 ... ##   ..@ Dim     : int [1:2] 3765 884583 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:3765] \"TNMD\" \"FGR\" \"CFH\" \"CFTR\" ... ##   .. ..$ : chr [1:884583] \"FCAImmP7579224-ATTACTCTCGATGAGG\" \"FCAImmP7579224-CAGCCGAGTACATCCA\" \"FCAImmP7579224-TGCTACCTCATGTAGC\" \"FCAImmP7579224-ACGGCCACAAGCTGAG\" ... ##   ..@ x       : num [1:201165610] 2.211 0.965 0.965 2.015 1.447 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    884583 obs. of  4 variables: ##  $ Batch   : chr  \"F45\" \"F45\" \"F45\" \"F45\" ... ##  $ Stage   : Factor w/ 11 levels \"4 PCW\",\"7 PCW\",..: 7 7 7 7 7 7 7 7 7 7 ... ##  $ Tissue  : Factor w/ 9 levels \"Bone Marrow\",..: 6 6 6 6 6 6 6 6 6 6 ... ##  $ CellType: Factor w/ 13 levels \"B cells\",\"Endothelium\",..: 8 4 8 8 1 8 8 8 8 8 ..."},{"path":"/articles/Unsupervised_integration.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"2.2 Visualization of raw data","title":"SIGNAL integration for unlabeled datasets","text":"","code":"Colors = distinctColorPalette(13) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p3 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, p3, align = 'h', axis = \"b\", nrow = 1)"},{"path":"/articles/Unsupervised_integration.html","id":"signal-integration-using-tissue-and-stage-as-group-variables-in-a-two-group-setting","dir":"Articles","previous_headings":"","what":"2.3 SIGNAL integration using ‘tissue’ and ‘stage’ as group variables in a two-group setting","title":"SIGNAL integration for unlabeled datasets","text":"","code":"signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Tissue\", \"Stage\"), b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, q3, align = 'h', axis = \"b\", nrow = 1)"},{"path":"/articles/Unsupervised_integration.html","id":"application-on-the-mouse-islet-atlas","dir":"Articles","previous_headings":"","what":"3. Application on the mouse islet atlas","title":"SIGNAL integration for unlabeled datasets","text":"next apply SIGNAL integrate recently published mouse islet atlas using three-group setting.","code":""},{"path":"/articles/Unsupervised_integration.html","id":"load-data-matrix-and-metadata-1","dir":"Articles","previous_headings":"","what":"3.1 Load data matrix and metadata","title":"SIGNAL integration for unlabeled datasets","text":"perform data integration normalized scRNA-seq gene expression matrix. HVGs provided authors used.","code":"X = readRDS('/home/server/zy/group_scripts/datasets_preparation/Mouse_islet_atlas/X.rds') meta = readRDS('/home/server/zy/group_scripts/datasets_preparation/Mouse_islet_atlas/Meta.rds') str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:95717760] 8 11 13 14 15 17 21 22 24 25 ... ##   ..@ p       : int [1:264019] 0 506 924 1379 1666 1924 2017 2176 2526 2855 ... ##   ..@ Dim     : int [1:2] 4000 264018 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:4000] \"Glycam1\" \"Ighg2b\" \"Ighm\" \"Hbb-bs\" ... ##   .. ..$ : chr [1:264018] \"CAAGATCGTCCAGTTA-1-SRR7610301-NOD_elimination\" \"GATGAAAGTTGTCGCG-1-SRR7610298-NOD_elimination\" \"AGTCTTTAGGAGCGTT-1-SRR7610301-NOD_elimination\" \"CTTCCTTGTACCCAGC-1-MUC13640-VSG\" ... ##   ..@ x       : num [1:95717760] 1.46 2.17 1.46 1.17 1.17 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    264018 obs. of  5 variables: ##  $ Batch   : chr  \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610301\" \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610298\" \"mouse_pancreatic_islet_atlas_Hrovatin__NOD_elimination__SRR7610301\" \"mouse_pancreatic_islet_atlas_Hrovatin__VSG__MUC13640\" ... ##  $ CellType: Factor w/ 11 levels \"α\",\"β\",\"δ\",\"PP\",..: 6 4 8 9 11 4 3 7 4 9 ... ##  $ Stage   : Factor w/ 9 levels \"E\",\"2w\",\"5w\",..: 6 6 6 7 4 8 7 7 8 7 ... ##  $ Disease : Factor w/ 4 levels \"normal\",\"type 1 diabetes mellitus\",..: 2 2 2 3 1 3 3 3 3 3 ... ##  $ Sex     : chr  \"female\" \"female\" \"female\" \"male\" ..."},{"path":"/articles/Unsupervised_integration.html","id":"visualization-of-raw-data-1","dir":"Articles","previous_headings":"","what":"3.2 Visualization of raw data","title":"SIGNAL integration for unlabeled datasets","text":"","code":"Colors = distinctColorPalette(11) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Sex\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p3 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Disease\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p4 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, p3, p4, align = 'h', axis = \"b\", nrow = 2)"},{"path":"/articles/Unsupervised_integration.html","id":"signal-integration-using-sex-disease-and-stage-as-group-variables-in-a-two-group-setting","dir":"Articles","previous_headings":"","what":"3.3 SIGNAL integration using ‘sex’, ‘disease’, and ‘stage’ as group variables in a two-group setting","title":"SIGNAL integration for unlabeled datasets","text":"","code":"signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Sex\", \"Disease\", \"Stage\"), b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Sex\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Disease\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q4 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, q3, q4, align = 'h', axis = \"b\", nrow = 2) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1       randomcoloR_1.1.0.1 ggpubr_0.6.0        ## [4] ggplot2_3.4.4       uwot_0.2.2          irlba_2.3.5.1       ## [7] Matrix_1.5-4.1      SIGNAL_1.0.0        ##  ## loaded via a namespace (and not attached): ##  [1] matrixStats_1.0.0        fs_1.6.4                 flock_0.7                ##  [4] RcppAnnoy_0.0.22         doParallel_1.0.17        tools_4.2.3              ##  [7] backports_1.4.1          bslib_0.7.0              utf8_1.2.4               ## [10] R6_2.5.1                 BiocGenerics_0.44.0      colorspace_2.1-0         ## [13] withr_3.0.0              tidyselect_1.2.1         bit_4.0.5                ## [16] curl_5.2.1               compiler_4.2.3           bigparallelr_0.3.2       ## [19] textshaping_0.3.7        cli_3.6.2                BiocNeighbors_1.16.0     ## [22] desc_1.4.3               labeling_0.4.3           sass_0.4.9               ## [25] scales_1.3.0             pkgdown_2.0.7            systemfonts_1.0.6        ## [28] stringr_1.5.1            digest_0.6.35            rmarkdown_2.26           ## [31] pkgconfig_2.0.3          htmltools_0.5.8.1        sparseMatrixStats_1.10.0 ## [34] MatrixGenerics_1.10.0    fastmap_1.1.1            highr_0.10               ## [37] rlang_1.1.3              rstudioapi_0.15.0        jquerylib_0.1.4          ## [40] generics_0.1.3           farver_2.1.1             jsonlite_1.8.8           ## [43] mclust_6.0.0             BiocParallel_1.32.6      dplyr_1.1.4              ## [46] car_3.1-2                magrittr_2.0.3           Rcpp_1.0.12              ## [49] munsell_0.5.1            S4Vectors_0.36.2         fansi_1.0.6              ## [52] abind_1.4-5              lifecycle_1.0.4          stringi_1.8.3            ## [55] yaml_2.3.8               carData_3.0-5            Rtsne_0.17               ## [58] grid_4.2.3               parallel_4.2.3           lattice_0.21-8           ## [61] knitr_1.46               ps_1.7.6                 pillar_1.9.0             ## [64] ggsignif_0.6.4           bigstatsr_1.5.12         codetools_0.2-19         ## [67] stats4_4.2.3             bigassertr_0.1.6         glue_1.7.0               ## [70] evaluate_0.23            V8_4.4.2                 vctrs_0.6.5              ## [73] foreach_1.5.2            gtable_0.3.5             purrr_1.0.2              ## [76] tidyr_1.3.1              cachem_1.0.8             xfun_0.43                ## [79] broom_1.0.5              RcppEigen_0.3.4.0.0      ff_4.0.12                ## [82] RSpectra_0.16-1          rstatix_0.7.2            ragg_1.2.7               ## [85] tibble_3.2.1             iterators_1.0.14         memoise_2.0.1            ## [88] cluster_2.1.4            rmio_0.4.0"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yang Zhou. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhou Y (2024). SIGNAL: SIngle-cell Group techNical vAriation Learning (SIGNAL). https://github.com/yzhou1999/SIGNAL, https://yzhou1999.github.io/SIGNAL/.","code":"@Manual{,   title = {SIGNAL: SIngle-cell Group techNical vAriation Learning (SIGNAL)},   author = {Yang Zhou},   year = {2024},   note = {https://github.com/yzhou1999/SIGNAL, https://yzhou1999.github.io/SIGNAL/}, }"},{"path":"/index.html","id":"signal-single-cell-group-technical-variations-learning","dir":"","previous_headings":"","what":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"SIGNAL R package data integration learning group technical variations.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"run SIGNAL, install GitHub devtools directly:","code":"install.packages('devtools') library(devtools) devtools::install_github(\"yzhou1999/SIGNAL\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"usage examples, please see vignettes directory repository. Supervised integration using SIGNAL SIGNAL integration unlabeled datasets Multi-scale analysis using SIGNAL Knowledge transfer reference query using SIGNAL","code":""},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"SIGNAL successfully installed used Windows, Linux Mac OS (R version >= 4.0.2). dependencies including: base, stats, Matrix, matrixStats, sparseMatrixStats, mclust, Rcpp, RcppEigen, irlba, BiocNeighbors, bigstatsr, dplyr, RSpectra.","code":""},{"path":"/reference/Run.LabelTransfer.Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"Predict cell labels query data using cell labels reference data.","code":""},{"path":"/reference/Run.LabelTransfer.Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"","code":"Run.LabelTransfer.Single(   ref_data,   ref_group,   query_data,   do.cosine = T,   do.scale = F,   conf.score = T,   proj.dims = 30,   eta = 0.25,   smooth.k = 5 )"},{"path":"/reference/Run.LabelTransfer.Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"ref_data Reference data matrix. ref_group Reference labels. query_data Query data matrix. .cosine Whether cosine normalize data matrices. .scale Whether perform scaling. conf.score Whether calculate confidence scores. proj.dims Projection dimension query data reference data. eta proportion cells considered reliably projected. smooth.k Using kNNs smooth scores.","code":""},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"Predict cell labels data matrix using given cell labels.","code":""},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"","code":"Run.PGTV.Single.Cycle(   data,   group,   do.cosine = T,   do.scale = F,   max.iters = 20,   thresh = 1e-05 )"},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"data Data matrix. group Given labels. .cosine Whether cosine normalize data matrices. .scale Stopping threshold classification agreement metrics. max.iters maximum number iterations. thresh Whether perform scaling.","code":""},{"path":"/reference/Run.PGTV.Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels using group technial effects. — Run.PGTV.Single","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"Predict cell labels using group technial effects.","code":""},{"path":"/reference/Run.PGTV.Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"","code":"Run.PGTV.Single(ref_data, ref_group, query_data, do.cosine = T, do.scale = F)"},{"path":"/reference/Run.PGTV.Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"ref_data Reference data matrix. ref_group Reference labels. query_data Query data matrix. .cosine Whether cosine normalize data matrices. .scale Whether perform scaling.","code":""},{"path":"/reference/Run.gcPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-centralized principal component analysis — Run.gcPCA","title":"Group-centralized principal component analysis — Run.gcPCA","text":"Group-centralized principal component analysis","code":""},{"path":"/reference/Run.gcPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-centralized principal component analysis — Run.gcPCA","text":"","code":"Run.gcPCA(   X,   meta,   g_factor,   b_factor,   lambda = 50,   npcs = 30,   excluded.cells = NULL,   output.all = FALSE,   do.scale = F,   do.cosine = F,   block.sizeGB = 2,   block.size = 4000 )"},{"path":"/reference/Run.gcPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-centralized principal component analysis — Run.gcPCA","text":"X Input data matrix. meta Input metadata (data.frame). g_factor Group variable (s). Multiple group variables allowed, \"cell type\". examples include: \"cell type\", c(\"stage\", \"tissue\"), c(\"sex\", \"disease\", \"stage\"). b_factor Batch variable (s). lambda Tuning parameter. npcs many dimensions reduce. excluded.cells Metadata cells used. output.Whether return calculated values. .scale Whether perform global scaling. .cosine Whether cosine normalize integration result. block.sizeGB Memory settings block computing. block.size Block size.","code":""},{"path":"/reference/compute_cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute covariance matrix — compute_cov","title":"Compute covariance matrix — compute_cov","text":"Compute covariance matrix","code":""},{"path":"/reference/compute_cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute covariance matrix — compute_cov","text":"","code":"compute_cov(X, G, block.size)"},{"path":"/reference/compute_cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute covariance matrix — compute_cov","text":"X Input FBM object. G Group ont-hot matrix. block.size Block size.","code":""},{"path":"/reference/cosineNorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine normalize data matrix — cosineNorm","title":"Cosine normalize data matrix — cosineNorm","text":"Cosine normalize data matrix","code":""},{"path":"/reference/cosineNorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine normalize data matrix — cosineNorm","text":"","code":"cosineNorm(x)"},{"path":"/reference/cosineNorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine normalize data matrix — cosineNorm","text":"x Input data matrix.","code":""},{"path":"/reference/group_mmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the sum of the outer product of the scaled group means — group_mmt","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"Compute sum outer product scaled group means","code":""},{"path":"/reference/group_mmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"","code":"group_mmt(X, G, output.all = FALSE)"},{"path":"/reference/group_mmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"X Input FBM object. G Group one-hot matrix. output.Whether output results.","code":""},{"path":"/reference/group_onehot.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"Compute one-hot matrix given data frame variable (s)","code":""},{"path":"/reference/group_onehot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"","code":"group_onehot(x, ivar)"},{"path":"/reference/group_onehot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"x Input data frame. ivar Variable (s) one-hot computation.","code":""},{"path":"/reference/scale_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale data matrix — scale_data","title":"Scale data matrix — scale_data","text":"Scale data matrix","code":""},{"path":"/reference/scale_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale data matrix — scale_data","text":"","code":"scale_data(   data.x,   do.center = T,   do.scale = T,   row.means = NULL,   row.sds = NULL )"},{"path":"/reference/scale_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale data matrix — scale_data","text":"data.x Input data matrix. .center Whether center row values. (default TRUE) .scale Whether scale row values. (default TRUE) row.means provided row means center. (default NULL) row.sds provided row standard deviations scale. (default NULL)","code":""}]
