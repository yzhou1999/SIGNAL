[{"path":"/articles/Knowledge_transfer.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Knowledge transfer from reference to query using SIGNAL","text":"SIGNAL allows knowledge transfer form reference data query data, containing two tasks: reference-based annotation reference-based integration. latter integrates data based labels predicted former. vignette, use two human cortex scRNA-seq datasets (human MTG human cortex datasets) demonstrate perform two tasks SIGNAL. use human MTG reference human cortex query. removed cell type reference test label annotation integration scenarios novel cell types query data.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(randomcoloR) library(cowplot) set.seed(2024)"},{"path":"/articles/Knowledge_transfer.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Knowledge transfer from reference to query using SIGNAL","text":"identify HVGs reference read expression matrix reference query normalized subset HVGs. Among , 2000 genes query overlapped identified HVGs. represent missing gene query 0.","code":"ref_X = readRDS(paste0(\"/home/server/zy/group_scripts/datasets_preparation/Human_MTG/X.rds\")) ref_meta = readRDS(paste0(\"/home/server/zy/group_scripts/datasets_preparation/Human_MTG/meta.rds\"))[, c(\"Batch\", \"SubClass\")] ref_meta$Dataset = \"reference\" ref_meta = ref_meta[which(!ref_meta$SubClass %in% c(\"Sst Chodl\", \"L5 ET\", \"Endothelial\", \"L4 IT\", \"Oligodendrocyte\", \"L2/3 IT\")), ] ref_X = ref_X[, rownames(ref_meta)]  query_X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Human_cortex/new_X.rds\") query_meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Human_cortex/meta.rds\")[, c(\"Batch\", \"SubClass\")] query_meta$Dataset = \"query\" str(ref_X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:47935347] 17 42 44 59 82 87 91 100 104 106 ... ##   ..@ p       : int [1:85652] 0 540 1177 1961 2453 2940 3427 3969 4793 5192 ... ##   ..@ Dim     : int [1:2] 4000 85651 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:4000] \"MIR1302-2HG\" \"LINC02593\" \"SAMD11\" \"TMEM88B\" ... ##   .. ..$ : chr [1:85651] \"AAACCCAAGTGATCGG-L8TX_191029_01_A07-1156636564\" \"AAACCCACAGGACTTT-L8TX_191029_01_A07-1156636564\" \"AAACCCAGTCTCGGAC-L8TX_191029_01_A07-1156636564\" \"AAACCCAGTTCTCGCT-L8TX_191029_01_A07-1156636564\" ... ##   ..@ x       : num [1:47935347] 3.445 0.446 0.753 1.89 0.446 ... ##   ..@ factors : list() str(ref_meta) ## 'data.frame':    85651 obs. of  3 variables: ##  $ Batch   : chr  \"Donor1\" \"Donor1\" \"Donor1\" \"Donor1\" ... ##  $ SubClass: chr  \"Sst\" \"L5 IT\" \"L5 IT\" \"L5 IT\" ... ##  $ Dataset : chr  \"reference\" \"reference\" \"reference\" \"reference\" ... str(query_X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:173988543] 11 46 48 61 63 69 70 71 72 77 ... ##   ..@ p       : int [1:379331] 0 354 792 1312 1726 2177 2699 3095 3549 4008 ... ##   ..@ Dim     : int [1:2] 2269 379330 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:2269] \"SAMD11\" \"TMEM88B\" \"VWA1\" \"HES5\" ... ##   .. ..$ : chr [1:379330] \"AAACCCAAGAGAGGTA-L8TX_190416_01_C06-871132075\" \"AAACGAAGTTGACGGA-L8TX_190416_01_C06-871132075\" \"AAACGAATCTCAAAGC-L8TX_190416_01_C06-871132075\" \"AAACGCTGTACTCGCG-L8TX_190416_01_C06-871132075\" ... ##   ..@ x       : num [1:173988543] 1.83 0.84 0.84 1.29 0.84 ... ##   ..@ factors : list() str(query_meta) ## 'data.frame':    379330 obs. of  3 variables: ##  $ Batch   : chr  \"H17.26.003\" \"H17.26.003\" \"H17.26.003\" \"H17.26.003\" ... ##  $ SubClass: chr  \"L2/3 IT\" \"L2/3 IT\" \"L2/3 IT\" \"L2/3 IT\" ... ##  $ Dataset : chr  \"query\" \"query\" \"query\" \"query\" ... zero_m = sparseMatrix(i = integer(0), j = integer(0), dims = c(nrow(ref_X) - nrow(query_X), ncol(query_X))) rownames(zero_m) = setdiff(rownames(ref_X), rownames(query_X)) colnames(zero_m) = colnames(query_X) query_X = rbind(query_X, zero_m)[rownames(ref_X), ]"},{"path":"/articles/Knowledge_transfer.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"Visualization of raw data","title":"Knowledge transfer from reference to query using SIGNAL","text":"","code":"Colors = distinctColorPalette(24) X = cbind(ref_X, query_X) meta = rbind.data.frame(ref_meta, query_meta) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Dataset\", palette = c(\"#196534\", \"#9ED089\"), legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"SubClass\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, align = 'h', axis = \"b\")"},{"path":"/articles/Knowledge_transfer.html","id":"label-prediction-and-reference-based-integration","dir":"Articles","previous_headings":"","what":"Label prediction and reference-based integration","title":"Knowledge transfer from reference to query using SIGNAL","text":"check whether SIGNAL can distinguish cell types removed reference.","code":"predicted_labels = Run.LabelTransfer.Single(ref_X, ref_meta$SubClass, query_X) str(predicted_labels) ## 'data.frame':    379330 obs. of  2 variables: ##  $ Prediction: chr  \"L6 IT\" \"L6 IT\" \"L5 IT\" \"L6 IT\" ... ##  $ Confidence: num  0.517 0.595 0.571 0.497 0.581 ... meta$Prediction = c(ref_meta$SubClass, predicted_labels$Prediction) meta$Confidence = c(rep(NA, nrow(ref_meta)), predicted_labels$Confidence) signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Prediction\", \"Dataset\"), b_factor = \"Batch\",                        excluded.cells = which(meta$Dataset== 'query')[which(predicted_labels$Confidence < 0.8)]) ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Dataset\", palette = c(\"#196534\", \"#9ED089\"), legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"SubClass\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap[which(meta$Dataset == \"query\"),], x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Confidence\", legend = \"right\") + gradient_color(c(\"red\",  \"white\", \"blue\")) plot_grid(q1, q2, q3, align = 'h', axis = \"b\", nrow = 1) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1       randomcoloR_1.1.0.1 ggpubr_0.6.0        ## [4] ggplot2_3.4.4       uwot_0.2.2          irlba_2.3.5.1       ## [7] Matrix_1.5-4.1      SIGNAL_1.0.0        ##  ## loaded via a namespace (and not attached): ##  [1] matrixStats_1.0.0        fs_1.6.4                 flock_0.7                ##  [4] RcppAnnoy_0.0.22         doParallel_1.0.17        tools_4.2.3              ##  [7] backports_1.4.1          bslib_0.7.0              utf8_1.2.4               ## [10] R6_2.5.1                 BiocGenerics_0.44.0      colorspace_2.1-0         ## [13] withr_3.0.0              tidyselect_1.2.1         bit_4.0.5                ## [16] curl_5.2.1               compiler_4.2.3           bigparallelr_0.3.2       ## [19] textshaping_0.3.7        cli_3.6.2                BiocNeighbors_1.16.0     ## [22] desc_1.4.3               labeling_0.4.3           sass_0.4.9               ## [25] scales_1.3.0             pkgdown_2.0.7            systemfonts_1.0.6        ## [28] stringr_1.5.1            digest_0.6.35            rmarkdown_2.26           ## [31] pkgconfig_2.0.3          htmltools_0.5.8.1        sparseMatrixStats_1.10.0 ## [34] MatrixGenerics_1.10.0    fastmap_1.1.1            highr_0.10               ## [37] rlang_1.1.3              rstudioapi_0.15.0        jquerylib_0.1.4          ## [40] generics_0.1.3           farver_2.1.1             jsonlite_1.8.8           ## [43] mclust_6.0.0             BiocParallel_1.32.6      dplyr_1.1.4              ## [46] car_3.1-2                magrittr_2.0.3           Rcpp_1.0.12              ## [49] munsell_0.5.1            S4Vectors_0.36.2         fansi_1.0.6              ## [52] abind_1.4-5              lifecycle_1.0.4          stringi_1.8.3            ## [55] yaml_2.3.8               carData_3.0-5            Rtsne_0.17               ## [58] grid_4.2.3               parallel_4.2.3           lattice_0.21-8           ## [61] knitr_1.46               ps_1.7.6                 pillar_1.9.0             ## [64] ggsignif_0.6.4           bigstatsr_1.5.12         codetools_0.2-19         ## [67] stats4_4.2.3             bigassertr_0.1.6         glue_1.7.0               ## [70] evaluate_0.23            V8_4.4.2                 vctrs_0.6.5              ## [73] foreach_1.5.2            gtable_0.3.5             purrr_1.0.2              ## [76] tidyr_1.3.1              cachem_1.0.8             xfun_0.43                ## [79] broom_1.0.5              RcppEigen_0.3.4.0.0      ff_4.0.12                ## [82] RSpectra_0.16-1          rstatix_0.7.2            ragg_1.2.7               ## [85] tibble_3.2.1             iterators_1.0.14         memoise_2.0.1            ## [88] cluster_2.1.4            rmio_0.4.0"},{"path":"/articles/Multiscale_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Multi-scale analysis using SIGNAL","text":"can use SIGNAL perform multi-scale analysis single-cell data identify cell subtypes specific tissues, conditions, developmental stages. vignette, demonstrate recently published developing human immune cell atlas SIGNAL can used integrate way preserves differences tissues developmental stages.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(randomcoloR) library(cowplot) set.seed(2024)"},{"path":"/articles/Multiscale_analysis.html","id":"load-data-matrix-and-metadata","dir":"Articles","previous_headings":"","what":"Load data matrix and metadata","title":"Multi-scale analysis using SIGNAL","text":"perform data integration normalized scRNA-seq gene expression matrix. HVGs provided authors used.","code":"X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/X.rds\") meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Developing_immune/meta.rds\") str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:201165610] 1 9 10 23 37 44 49 50 52 54 ... ##   ..@ p       : int [1:884584] 0 491 904 1321 1864 2260 2709 3148 3657 4110 ... ##   ..@ Dim     : int [1:2] 3765 884583 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:3765] \"TNMD\" \"FGR\" \"CFH\" \"CFTR\" ... ##   .. ..$ : chr [1:884583] \"FCAImmP7579224-ATTACTCTCGATGAGG\" \"FCAImmP7579224-CAGCCGAGTACATCCA\" \"FCAImmP7579224-TGCTACCTCATGTAGC\" \"FCAImmP7579224-ACGGCCACAAGCTGAG\" ... ##   ..@ x       : num [1:201165610] 2.211 0.965 0.965 2.015 1.447 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    884583 obs. of  4 variables: ##  $ Batch   : chr  \"F45\" \"F45\" \"F45\" \"F45\" ... ##  $ Stage   : Factor w/ 11 levels \"4 PCW\",\"7 PCW\",..: 7 7 7 7 7 7 7 7 7 7 ... ##  $ Tissue  : Factor w/ 9 levels \"Bone Marrow\",..: 6 6 6 6 6 6 6 6 6 6 ... ##  $ CellType: Factor w/ 13 levels \"B cells\",\"Endothelium\",..: 8 4 8 8 1 8 8 8 8 8 ..."},{"path":"/articles/Multiscale_analysis.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"Visualization of raw data","title":"Multi-scale analysis using SIGNAL","text":"","code":"Colors = distinctColorPalette(13) pca_res = irlba(t(X), nv = 50) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p3 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, p3, align = 'h', axis = \"b\", nrow = 1)"},{"path":"/articles/Multiscale_analysis.html","id":"signal-integration","dir":"Articles","previous_headings":"","what":"SIGNAL integration","title":"Multi-scale analysis using SIGNAL","text":"","code":"signal_emb = Run.gcPCA(X, meta, g_factor = c(\"Tissue\", \"Stage\"), b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Tissue\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q3 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Stage\", palette = Colors, legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, q3, align = 'h', axis = \"b\", nrow = 1) sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1       randomcoloR_1.1.0.1 ggpubr_0.6.0        ## [4] ggplot2_3.4.4       uwot_0.2.2          irlba_2.3.5.1       ## [7] Matrix_1.5-4.1      SIGNAL_1.0.0        ##  ## loaded via a namespace (and not attached): ##  [1] matrixStats_1.0.0        fs_1.6.4                 flock_0.7                ##  [4] RcppAnnoy_0.0.22         doParallel_1.0.17        tools_4.2.3              ##  [7] backports_1.4.1          bslib_0.7.0              utf8_1.2.4               ## [10] R6_2.5.1                 BiocGenerics_0.44.0      colorspace_2.1-0         ## [13] withr_3.0.0              tidyselect_1.2.1         bit_4.0.5                ## [16] curl_5.2.1               compiler_4.2.3           bigparallelr_0.3.2       ## [19] textshaping_0.3.7        cli_3.6.2                BiocNeighbors_1.16.0     ## [22] desc_1.4.3               labeling_0.4.3           sass_0.4.9               ## [25] scales_1.3.0             pkgdown_2.0.7            systemfonts_1.0.6        ## [28] stringr_1.5.1            digest_0.6.35            rmarkdown_2.26           ## [31] pkgconfig_2.0.3          htmltools_0.5.8.1        sparseMatrixStats_1.10.0 ## [34] MatrixGenerics_1.10.0    fastmap_1.1.1            highr_0.10               ## [37] rlang_1.1.3              rstudioapi_0.15.0        jquerylib_0.1.4          ## [40] generics_0.1.3           farver_2.1.1             jsonlite_1.8.8           ## [43] mclust_6.0.0             BiocParallel_1.32.6      dplyr_1.1.4              ## [46] car_3.1-2                magrittr_2.0.3           Rcpp_1.0.12              ## [49] munsell_0.5.1            S4Vectors_0.36.2         fansi_1.0.6              ## [52] abind_1.4-5              lifecycle_1.0.4          stringi_1.8.3            ## [55] yaml_2.3.8               carData_3.0-5            Rtsne_0.17               ## [58] grid_4.2.3               parallel_4.2.3           lattice_0.21-8           ## [61] knitr_1.46               ps_1.7.6                 pillar_1.9.0             ## [64] ggsignif_0.6.4           bigstatsr_1.5.12         codetools_0.2-19         ## [67] stats4_4.2.3             bigassertr_0.1.6         glue_1.7.0               ## [70] evaluate_0.23            V8_4.4.2                 vctrs_0.6.5              ## [73] foreach_1.5.2            gtable_0.3.5             purrr_1.0.2              ## [76] tidyr_1.3.1              cachem_1.0.8             xfun_0.43                ## [79] broom_1.0.5              RcppEigen_0.3.4.0.0      ff_4.0.12                ## [82] RSpectra_0.16-1          rstatix_0.7.2            ragg_1.2.7               ## [85] tibble_3.2.1             iterators_1.0.14         memoise_2.0.1            ## [88] cluster_2.1.4            rmio_0.4.0"},{"path":"/articles/Supervised_integration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Supervised integration using SIGNAL","text":"SIGNAL can used perform supervised integration single-cell data. Given metadata meta (data frame containing meta information) inputs, SIGNAL requires batch variable b least one group variable g. Using feature--cell data matrix X (matrix-like object) batch group variables, SIGNAL embeds X multiple batches low-dimensional space affected batch effects, subgroups group variables different batches aligned together. vignette demonstrate use SIGNAL perform supervised integration, .e., integration using ‘cell type’ group variable.","code":"library(SIGNAL) library(irlba) library(uwot) library(ggpubr) library(cowplot) set.seed(2024)"},{"path":"/articles/Supervised_integration.html","id":"load-data-matrix-and-metadata","dir":"Articles","previous_headings":"","what":"Load data matrix and metadata","title":"Supervised integration using SIGNAL","text":"demonstrate SIGNAL integration commonly used single-cell RNA sequencing (scRNA-seq) dataset cell lines. highly variable genes (HVGs) already selected used perform integration. can take look data.","code":"X = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Jurkat_293t/X.rds\") meta = readRDS(\"/home/server/zy/group_scripts/datasets_preparation/Jurkat_293t/meta.rds\") str(X) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:3137390] 3 12 14 26 30 35 36 40 43 44 ... ##   ..@ p       : int [1:9532] 0 325 590 932 1251 1593 1944 2318 2644 2963 ... ##   ..@ Dim     : int [1:2] 2000 9531 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:2000] \"AP006222.2\" \"RP11-206L10.2\" \"C1orf170\" \"HES4\" ... ##   .. ..$ : chr [1:9531] \"AAACATACACTGGT-1\" \"AAACATACAGACTC-1\" \"AAACATTGACCAAC-1\" \"AAACATTGAGGCGA-1\" ... ##   ..@ x       : num [1:3137390] 1.9 1.975 1.53 0.937 1.121 ... ##   ..@ factors : list() str(meta) ## 'data.frame':    9531 obs. of  2 variables: ##  $ CellType: Factor w/ 2 levels \"293t\",\"jurkat\": 1 1 1 1 1 1 1 1 1 1 ... ##  $ Batch   : Factor w/ 3 levels \"Batch_1\",\"Batch_2\",..: 1 1 1 1 1 1 1 1 1 1 ..."},{"path":"/articles/Supervised_integration.html","id":"visualization-of-raw-data","dir":"Articles","previous_headings":"","what":"Visualization of raw data","title":"Supervised integration using SIGNAL","text":"Let us visualize raw data using PCA UMAP.  can see batch effects Jurkat cells batch 2 batch 3.","code":"pca_res = irlba(t(X), nv = 30) raw_emb = as.matrix(pca_res$u %*% diag(pca_res$d)) raw_umap = as.data.frame(umap(raw_emb)) colnames(raw_umap) = c(\"UMAP1\", \"UMAP2\") raw_umap = cbind.data.frame(meta, raw_umap) p1 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Batch\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) p2 = ggscatter(raw_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(p1, p2, align = 'h', axis = \"b\")"},{"path":"/articles/Supervised_integration.html","id":"signal-supervised-integration","dir":"Articles","previous_headings":"","what":"SIGNAL supervised integration","title":"Supervised integration using SIGNAL","text":"perform SIGNAL supervised integration visualize integrated result. usually takes short time. can integrate 1 million cells ~2 minutes.","code":"signal_emb = Run.gcPCA(X, meta, g_factor = \"CellType\", b_factor = \"Batch\") ## Run gcPCA! ## gcPCA done! signal_umap = as.data.frame(umap(t(signal_emb))) colnames(signal_umap) = c(\"UMAP1\", \"UMAP2\") signal_umap = cbind.data.frame(meta, signal_umap) q1 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"Batch\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) q2 = ggscatter(signal_umap, x = \"UMAP1\", y = \"UMAP2\", size = 0.1, color = \"CellType\", palette = \"npg\", legend = \"right\") +    guides(colour = guide_legend(override.aes = list(size = 2))) plot_grid(q1, q2, align = 'h', axis = \"b\") sessionInfo() ## R version 4.2.3 (2023-03-15) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 22.10 ##  ## Matrix products: default ## BLAS/LAPACK: /home/server/anaconda3/envs/zy/lib/libopenblasp-r0.3.21.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] cowplot_1.1.1  ggpubr_0.6.0   ggplot2_3.4.4  uwot_0.2.2     irlba_2.3.5.1  ## [6] Matrix_1.5-4.1 SIGNAL_1.0.0   ##  ## loaded via a namespace (and not attached): ##  [1] MatrixGenerics_1.10.0    sass_0.4.9               tidyr_1.3.1              ##  [4] jsonlite_1.8.8           foreach_1.5.2            carData_3.0-5            ##  [7] bslib_0.7.0              highr_0.10               stats4_4.2.3             ## [10] yaml_2.3.8               pillar_1.9.0             backports_1.4.1          ## [13] lattice_0.21-8           glue_1.7.0               RcppEigen_0.3.4.0.0      ## [16] digest_0.6.35            ggsignif_0.6.4           colorspace_2.1-0         ## [19] htmltools_0.5.8.1        pkgconfig_2.0.3          broom_1.0.5              ## [22] bigparallelr_0.3.2       rmio_0.4.0               purrr_1.0.2              ## [25] scales_1.3.0             RSpectra_0.16-1          ff_4.0.12                ## [28] BiocParallel_1.32.6      tibble_3.2.1             farver_2.1.1             ## [31] car_3.1-2                generics_0.1.3           cachem_1.0.8             ## [34] withr_3.0.0              BiocGenerics_0.44.0      cli_3.6.2                ## [37] magrittr_2.0.3           mclust_6.0.0             ps_1.7.6                 ## [40] memoise_2.0.1            evaluate_0.23            bigassertr_0.1.6         ## [43] fs_1.6.4                 fansi_1.0.6              doParallel_1.0.17        ## [46] rstatix_0.7.2            textshaping_0.3.7        tools_4.2.3              ## [49] lifecycle_1.0.4          matrixStats_1.0.0        S4Vectors_0.36.2         ## [52] munsell_0.5.1            ggsci_3.0.0              compiler_4.2.3           ## [55] pkgdown_2.0.7            jquerylib_0.1.4          systemfonts_1.0.6        ## [58] rlang_1.1.3              grid_4.2.3               iterators_1.0.14         ## [61] BiocNeighbors_1.16.0     rstudioapi_0.15.0        RcppAnnoy_0.0.22         ## [64] labeling_0.4.3           rmarkdown_2.26           gtable_0.3.5             ## [67] codetools_0.2-19         flock_0.7                abind_1.4-5              ## [70] bigstatsr_1.5.12         R6_2.5.1                 knitr_1.46               ## [73] dplyr_1.1.4              bit_4.0.5                fastmap_1.1.1            ## [76] utf8_1.2.4               ragg_1.2.7               desc_1.4.3               ## [79] parallel_4.2.3           Rcpp_1.0.12              vctrs_0.6.5              ## [82] tidyselect_1.2.1         xfun_0.43                sparseMatrixStats_1.10.0"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yang Zhou. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhou Y (2024). SIGNAL: SIngle-cell Group techNical vAriation Learning (SIGNAL). https://github.com/yzhou1999/SIGNAL, https://yzhou1999.github.io/SIGNAL/.","code":"@Manual{,   title = {SIGNAL: SIngle-cell Group techNical vAriation Learning (SIGNAL)},   author = {Yang Zhou},   year = {2024},   note = {https://github.com/yzhou1999/SIGNAL, https://yzhou1999.github.io/SIGNAL/}, }"},{"path":"/index.html","id":"signal-single-cell-group-technical-variations-learning","dir":"","previous_headings":"","what":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"SIGNAL R package data integration learning group technical variations.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"run SIGNAL, install GitHub devtools directly:","code":"install.packages('devtools') library(devtools) devtools::install_github(\"yzhou1999/SIGNAL\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"usage examples, please see vignettes directory repository. Supervised integration using SIGNAL Multi-scale analysis using SIGNAL Knowledge transfer reference query using SIGNAL","code":""},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"SIngle-cell Group techNical vAriation Learning (SIGNAL)","text":"SIGNAL successfully installed used Windows, Linux Mac OS (R version >= 4.0.2). dependencies including: base, stats, Matrix, matrixStats, sparseMatrixStats, mclust, Rcpp, RcppEigen, irlba, BiocNeighbors, bigstatsr, dplyr, RSpectra.","code":""},{"path":"/reference/Run.LabelTransfer.Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"Predict cell labels query data using cell labels reference data.","code":""},{"path":"/reference/Run.LabelTransfer.Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"","code":"Run.LabelTransfer.Single(   ref_data,   ref_group,   query_data,   do.cosine = T,   do.scale = F,   conf.score = T,   proj.dims = 30,   eta = 0.25,   smooth.k = 5 )"},{"path":"/reference/Run.LabelTransfer.Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels of query data using cell labels of reference data. — Run.LabelTransfer.Single","text":"ref_data Reference data matrix. ref_group Reference labels. query_data Query data matrix. .cosine Whether cosine normalize data matrices. .scale Whether perform scaling. conf.score Whether calculate confidence scores. proj.dims Projection dimension query data reference data. eta proportion cells considered reliably projected. smooth.k Using kNNs smooth scores.","code":""},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"Predict cell labels data matrix using given cell labels.","code":""},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"","code":"Run.PGTV.Single.Cycle(   data,   group,   do.cosine = T,   do.scale = F,   max.iters = 20,   thresh = 1e-05 )"},{"path":"/reference/Run.PGTV.Single.Cycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels for a data matrix using its given cell labels. — Run.PGTV.Single.Cycle","text":"data Data matrix. group Given labels. .cosine Whether cosine normalize data matrices. .scale Stopping threshold classification agreement metrics. max.iters maximum number iterations. thresh Whether perform scaling.","code":""},{"path":"/reference/Run.PGTV.Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict cell labels using group technial effects. — Run.PGTV.Single","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"Predict cell labels using group technial effects.","code":""},{"path":"/reference/Run.PGTV.Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"","code":"Run.PGTV.Single(ref_data, ref_group, query_data, do.cosine = T, do.scale = F)"},{"path":"/reference/Run.PGTV.Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict cell labels using group technial effects. — Run.PGTV.Single","text":"ref_data Reference data matrix. ref_group Reference labels. query_data Query data matrix. .cosine Whether cosine normalize data matrices. .scale Whether perform scaling.","code":""},{"path":"/reference/Run.gcPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-centralized principal component analysis — Run.gcPCA","title":"Group-centralized principal component analysis — Run.gcPCA","text":"Group-centralized principal component analysis","code":""},{"path":"/reference/Run.gcPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-centralized principal component analysis — Run.gcPCA","text":"","code":"Run.gcPCA(   X,   meta,   g_factor,   b_factor,   lambda = 50,   npcs = 30,   excluded.cells = NULL,   output.all = FALSE,   do.scale = F,   do.cosine = F,   block.sizeGB = 2,   block.size = 4000 )"},{"path":"/reference/Run.gcPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-centralized principal component analysis — Run.gcPCA","text":"X Input data matrix. meta Input metadata (data.frame). g_factor Group variable (s). b_factor Batch variable (s). lambda Tuning parameter. npcs many dimensions reduce. excluded.cells Metadata cells used. output.Whether return calculated values. .scale Whether perform global scaling. .cosine Whether cosine normalize integration result. block.sizeGB Memory settings block computing. block.size Block size.","code":""},{"path":"/reference/compute_cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute covariance matrix — compute_cov","title":"Compute covariance matrix — compute_cov","text":"Compute covariance matrix","code":""},{"path":"/reference/compute_cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute covariance matrix — compute_cov","text":"","code":"compute_cov(X, G, block.size)"},{"path":"/reference/compute_cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute covariance matrix — compute_cov","text":"X Input FBM object. G Group ont-hot matrix. block.size Block size.","code":""},{"path":"/reference/cosineNorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine normalize data matrix — cosineNorm","title":"Cosine normalize data matrix — cosineNorm","text":"Cosine normalize data matrix","code":""},{"path":"/reference/cosineNorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine normalize data matrix — cosineNorm","text":"","code":"cosineNorm(x)"},{"path":"/reference/cosineNorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine normalize data matrix — cosineNorm","text":"x Input data matrix.","code":""},{"path":"/reference/group_mmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the sum of the outer product of the scaled group means — group_mmt","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"Compute sum outer product scaled group means","code":""},{"path":"/reference/group_mmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"","code":"group_mmt(X, G, output.all = FALSE)"},{"path":"/reference/group_mmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the sum of the outer product of the scaled group means — group_mmt","text":"X Input FBM object. G Group one-hot matrix. output.Whether output results.","code":""},{"path":"/reference/group_onehot.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"Compute one-hot matrix given data frame variable (s)","code":""},{"path":"/reference/group_onehot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"","code":"group_onehot(x, ivar)"},{"path":"/reference/group_onehot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute one-hot matrix for given data frame and variable (s) — group_onehot","text":"x Input data frame. ivar Variable (s) one-hot computation.","code":""},{"path":"/reference/scale_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale data matrix — scale_data","title":"Scale data matrix — scale_data","text":"Scale data matrix","code":""},{"path":"/reference/scale_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale data matrix — scale_data","text":"","code":"scale_data(   data.x,   do.center = T,   do.scale = T,   row.means = NULL,   row.sds = NULL )"},{"path":"/reference/scale_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale data matrix — scale_data","text":"data.x Input data matrix. .center Whether center row values. (default TRUE) .scale Whether scale row values. (default TRUE) row.means provided row means center. (default NULL) row.sds provided row standard deviations scale. (default NULL)","code":""}]
